import type { DocumentNode } from 'graphql';
import type { Collection, CollectionTemplateable, Schema, TinaSchema } from '@tinacms/schema-tools';
import type { Bridge } from './bridge';
import { BinaryFilter, IndexDefinition, TernaryFilter } from './datalayer';
import { Level } from './level';
declare type IndexStatusEvent = {
    status: 'inprogress' | 'complete' | 'failed';
    error?: Error;
};
declare type IndexStatusCallback = (event: IndexStatusEvent) => Promise<void>;
export declare type OnPutCallback = (key: string, value: any) => Promise<void>;
export declare type OnDeleteCallback = (key: string) => Promise<void>;
export interface DatabaseArgs {
    bridge?: Bridge;
    level: Level;
    onPut?: (key: string, value: any) => Promise<void>;
    onDelete?: (key: string) => Promise<void>;
    tinaDirectory?: string;
    indexStatusCallback?: IndexStatusCallback;
    version?: boolean;
    namespace?: string;
}
export interface GitProvider {
    onPut: (key: string, value: string) => Promise<void>;
    onDelete: (key: string) => Promise<void>;
}
export declare type CreateDatabase = Omit<DatabaseArgs, 'level' | 'onPut' | 'onDelete'> & {
    databaseAdapter: Level;
    gitProvider: GitProvider;
    /**
     * @deprecated Use databaseAdapter instead
     */
    level?: Level;
    /**
     * @deprecated Use gitProvider instead
     */
    onPut?: OnPutCallback;
    /**
     * @deprecated Use gitProvider instead
     */
    onDelete?: OnDeleteCallback;
};
export declare type CreateLocalDatabaseArgs = Omit<DatabaseArgs, 'level'> & {
    port?: number;
    rootPath?: string;
};
export declare const createLocalDatabase: (config?: CreateLocalDatabaseArgs) => Database;
export declare const createDatabase: (config: CreateDatabase) => Database;
export declare const createDatabaseInternal: (config: DatabaseArgs) => Database;
/** Options for {@link Database.query} **/
export declare type QueryOptions = {
    fileExtension?: string;
    collection: string;
    filterChain?: (BinaryFilter | TernaryFilter)[];
    sort?: string;
    first?: number;
    last?: number;
    after?: string;
    before?: string;
    folder?: string;
};
export declare class Database {
    config: DatabaseArgs;
    bridge?: Bridge;
    rootLevel: Level;
    appLevel: Level | undefined;
    contentLevel: Level | undefined;
    tinaDirectory: string;
    indexStatusCallback: IndexStatusCallback | undefined;
    private readonly onPut;
    private readonly onDelete;
    private tinaSchema;
    private contentNamespace;
    private collectionIndexDefinitions;
    private _lookup;
    constructor(config: DatabaseArgs);
    private collectionForPath;
    private getGeneratedFolder;
    private updateDatabaseVersion;
    private getDatabaseVersion;
    private initLevel;
    getMetadata: (key: string) => Promise<any>;
    setMetadata: (key: string, value: string) => Promise<void>;
    get: <T extends object>(filepath: string) => Promise<T>;
    addPendingDocument: (filepath: string, data: {
        [key: string]: unknown;
    }) => Promise<void>;
    put: (filepath: string, data: {
        [key: string]: unknown;
    }, collectionName?: string) => Promise<boolean>;
    getTemplateDetailsForFile(collection: Collection<true>, data: {
        [key: string]: unknown;
    }): Promise<{
        template: {
            label?: string | boolean;
            name: string;
            nameOverride?: string;
            ui?: {
                itemProps?(item: Record<string, any>): {
                    key?: string;
                    label?: string | boolean;
                };
                defaultItem?: import("@tinacms/schema-tools").DefaultItem<Record<string, any>>;
                previewSrc?: string;
            };
            fields: ((import("@tinacms/schema-tools").StringField | import("@tinacms/schema-tools").NumberField | import("@tinacms/schema-tools").BooleanField | import("@tinacms/schema-tools").DateTimeField | import("@tinacms/schema-tools").ImageField | import("@tinacms/schema-tools").ReferenceField | import("@tinacms/schema-tools").PasswordField | import("@tinacms/schema-tools").RichTextField<false> | import("@tinacms/schema-tools").ObjectField<false>) & {})[];
        };
        info: CollectionTemplateable;
    }>;
    formatBodyOnPayload: (filepath: string, data: {
        [key: string]: unknown;
    }) => Promise<{
        [key: string]: unknown;
    }>;
    stringifyFile: (filepath: string, payload: {
        [key: string]: unknown;
    }, collection: Collection<true>) => Promise<string>;
    /**
     * Clears the internal cache of the tinaSchema and the lookup file. This allows the state to be reset
     */
    clearCache(): void;
    flush: (filepath: string) => Promise<string>;
    getLookup: (returnType: string) => Promise<LookupMapType>;
    getGraphQLSchema: () => Promise<DocumentNode>;
    getGraphQLSchemaFromBridge: () => Promise<DocumentNode>;
    getTinaSchema: (level?: Level) => Promise<Schema>;
    getSchema: (level?: Level, existingSchema?: Schema) => Promise<TinaSchema>;
    getIndexDefinitions: (level?: Level) => Promise<Record<string, Record<string, IndexDefinition>>>;
    documentExists: (fullpath: unknown) => Promise<boolean>;
    query: (queryOptions: QueryOptions, hydrator: any) => Promise<{
        edges: {
            node: any;
            cursor: string;
        }[];
        pageInfo: {
            hasPreviousPage: boolean;
            hasNextPage: boolean;
            startCursor: string;
            endCursor: string;
        };
    }>;
    private indexStatusCallbackWrapper;
    indexContent: ({ graphQLSchema, tinaSchema, lookup: lookupFromLockFile, }: {
        graphQLSchema: DocumentNode;
        tinaSchema: TinaSchema;
        lookup?: object;
    }) => Promise<{
        warnings: string[];
    }>;
    deleteContentByPaths: (documentPaths: string[]) => Promise<void>;
    indexContentByPaths: (documentPaths: string[]) => Promise<void>;
    delete: (filepath: string) => Promise<void>;
    _indexAllContent: (level: Level, schema?: Schema) => Promise<{
        warnings: string[];
    }>;
}
export declare type LookupMapType = GlobalDocumentLookup | CollectionDocumentLookup | CollectionFolderLookup | MultiCollectionDocumentLookup | MultiCollectionDocumentListLookup | CollectionDocumentListLookup | UnionDataLookup | NodeDocument;
declare type NodeDocument = {
    type: string;
    resolveType: 'nodeDocument';
};
declare type GlobalDocumentLookup = {
    type: string;
    resolveType: 'globalDocument';
    collection: string;
};
declare type CollectionDocumentLookup = {
    type: string;
    resolveType: 'collectionDocument';
    collection: string;
};
declare type CollectionFolderLookup = {
    type: string;
    resolveType: 'collectionFolder';
    collection: string;
};
declare type MultiCollectionDocumentLookup = {
    type: string;
    resolveType: 'multiCollectionDocument';
    createDocument: 'create';
    updateDocument: 'update';
};
declare type MultiCollectionDocumentListLookup = {
    type: string;
    resolveType: 'multiCollectionDocumentList';
    collections: string[];
};
export declare type CollectionDocumentListLookup = {
    type: string;
    resolveType: 'collectionDocumentList';
    collection: string;
};
declare type UnionDataLookup = {
    type: string;
    resolveType: 'unionData';
    collection?: string;
    typeMap: {
        [templateName: string]: string;
    };
};
export {};
